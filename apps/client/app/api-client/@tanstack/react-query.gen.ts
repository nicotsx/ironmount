// This file is auto-generated by @hey-api/openapi-ts

import {
	type Options,
	register,
	login,
	logout,
	getMe,
	getStatus,
	listVolumes,
	createVolume,
	testConnection,
	deleteVolume,
	getVolume,
	updateVolume,
	getContainersUsingVolume,
	mountVolume,
	unmountVolume,
	healthCheckVolume,
	listFiles,
	listRepositories,
	createRepository,
	deleteRepository,
	getRepository,
	listSnapshots,
	listBackupSchedules,
	createBackupSchedule,
	deleteBackupSchedule,
	getBackupSchedule,
	updateBackupSchedule,
	runBackupNow,
} from "../sdk.gen";
import { queryOptions, type UseMutationOptions, type DefaultError } from "@tanstack/react-query";
import type {
	RegisterData,
	RegisterResponse,
	LoginData,
	LoginResponse,
	LogoutData,
	LogoutResponse,
	GetMeData,
	GetStatusData,
	ListVolumesData,
	CreateVolumeData,
	CreateVolumeResponse,
	TestConnectionData,
	TestConnectionResponse,
	DeleteVolumeData,
	DeleteVolumeResponse,
	GetVolumeData,
	UpdateVolumeData,
	UpdateVolumeResponse,
	GetContainersUsingVolumeData,
	MountVolumeData,
	MountVolumeResponse,
	UnmountVolumeData,
	UnmountVolumeResponse,
	HealthCheckVolumeData,
	HealthCheckVolumeResponse,
	ListFilesData,
	ListRepositoriesData,
	CreateRepositoryData,
	CreateRepositoryResponse,
	DeleteRepositoryData,
	DeleteRepositoryResponse,
	GetRepositoryData,
	ListSnapshotsData,
	ListBackupSchedulesData,
	CreateBackupScheduleData,
	CreateBackupScheduleResponse,
	DeleteBackupScheduleData,
	DeleteBackupScheduleResponse,
	GetBackupScheduleData,
	UpdateBackupScheduleData,
	UpdateBackupScheduleResponse,
	RunBackupNowData,
	RunBackupNowResponse,
} from "../types.gen";
import { client as _heyApiClient } from "../client.gen";

export type QueryKey<TOptions extends Options> = [
	Pick<TOptions, "baseUrl" | "body" | "headers" | "path" | "query"> & {
		_id: string;
		_infinite?: boolean;
		tags?: ReadonlyArray<string>;
	},
];

const createQueryKey = <TOptions extends Options>(
	id: string,
	options?: TOptions,
	infinite?: boolean,
	tags?: ReadonlyArray<string>,
): [QueryKey<TOptions>[0]] => {
	const params: QueryKey<TOptions>[0] = {
		_id: id,
		baseUrl: options?.baseUrl || (options?.client ?? _heyApiClient).getConfig().baseUrl,
	} as QueryKey<TOptions>[0];
	if (infinite) {
		params._infinite = infinite;
	}
	if (tags) {
		params.tags = tags;
	}
	if (options?.body) {
		params.body = options.body;
	}
	if (options?.headers) {
		params.headers = options.headers;
	}
	if (options?.path) {
		params.path = options.path;
	}
	if (options?.query) {
		params.query = options.query;
	}
	return [params];
};

export const registerQueryKey = (options?: Options<RegisterData>) => createQueryKey("register", options);

/**
 * Register a new user
 */
export const registerOptions = (options?: Options<RegisterData>) => {
	return queryOptions({
		queryFn: async ({ queryKey, signal }) => {
			const { data } = await register({
				...options,
				...queryKey[0],
				signal,
				throwOnError: true,
			});
			return data;
		},
		queryKey: registerQueryKey(options),
	});
};

/**
 * Register a new user
 */
export const registerMutation = (
	options?: Partial<Options<RegisterData>>,
): UseMutationOptions<RegisterResponse, DefaultError, Options<RegisterData>> => {
	const mutationOptions: UseMutationOptions<RegisterResponse, DefaultError, Options<RegisterData>> = {
		mutationFn: async (localOptions) => {
			const { data } = await register({
				...options,
				...localOptions,
				throwOnError: true,
			});
			return data;
		},
	};
	return mutationOptions;
};

export const loginQueryKey = (options?: Options<LoginData>) => createQueryKey("login", options);

/**
 * Login with username and password
 */
export const loginOptions = (options?: Options<LoginData>) => {
	return queryOptions({
		queryFn: async ({ queryKey, signal }) => {
			const { data } = await login({
				...options,
				...queryKey[0],
				signal,
				throwOnError: true,
			});
			return data;
		},
		queryKey: loginQueryKey(options),
	});
};

/**
 * Login with username and password
 */
export const loginMutation = (
	options?: Partial<Options<LoginData>>,
): UseMutationOptions<LoginResponse, DefaultError, Options<LoginData>> => {
	const mutationOptions: UseMutationOptions<LoginResponse, DefaultError, Options<LoginData>> = {
		mutationFn: async (localOptions) => {
			const { data } = await login({
				...options,
				...localOptions,
				throwOnError: true,
			});
			return data;
		},
	};
	return mutationOptions;
};

export const logoutQueryKey = (options?: Options<LogoutData>) => createQueryKey("logout", options);

/**
 * Logout current user
 */
export const logoutOptions = (options?: Options<LogoutData>) => {
	return queryOptions({
		queryFn: async ({ queryKey, signal }) => {
			const { data } = await logout({
				...options,
				...queryKey[0],
				signal,
				throwOnError: true,
			});
			return data;
		},
		queryKey: logoutQueryKey(options),
	});
};

/**
 * Logout current user
 */
export const logoutMutation = (
	options?: Partial<Options<LogoutData>>,
): UseMutationOptions<LogoutResponse, DefaultError, Options<LogoutData>> => {
	const mutationOptions: UseMutationOptions<LogoutResponse, DefaultError, Options<LogoutData>> = {
		mutationFn: async (localOptions) => {
			const { data } = await logout({
				...options,
				...localOptions,
				throwOnError: true,
			});
			return data;
		},
	};
	return mutationOptions;
};

export const getMeQueryKey = (options?: Options<GetMeData>) => createQueryKey("getMe", options);

/**
 * Get current authenticated user
 */
export const getMeOptions = (options?: Options<GetMeData>) => {
	return queryOptions({
		queryFn: async ({ queryKey, signal }) => {
			const { data } = await getMe({
				...options,
				...queryKey[0],
				signal,
				throwOnError: true,
			});
			return data;
		},
		queryKey: getMeQueryKey(options),
	});
};

export const getStatusQueryKey = (options?: Options<GetStatusData>) => createQueryKey("getStatus", options);

/**
 * Get authentication system status
 */
export const getStatusOptions = (options?: Options<GetStatusData>) => {
	return queryOptions({
		queryFn: async ({ queryKey, signal }) => {
			const { data } = await getStatus({
				...options,
				...queryKey[0],
				signal,
				throwOnError: true,
			});
			return data;
		},
		queryKey: getStatusQueryKey(options),
	});
};

export const listVolumesQueryKey = (options?: Options<ListVolumesData>) => createQueryKey("listVolumes", options);

/**
 * List all volumes
 */
export const listVolumesOptions = (options?: Options<ListVolumesData>) => {
	return queryOptions({
		queryFn: async ({ queryKey, signal }) => {
			const { data } = await listVolumes({
				...options,
				...queryKey[0],
				signal,
				throwOnError: true,
			});
			return data;
		},
		queryKey: listVolumesQueryKey(options),
	});
};

export const createVolumeQueryKey = (options?: Options<CreateVolumeData>) => createQueryKey("createVolume", options);

/**
 * Create a new volume
 */
export const createVolumeOptions = (options?: Options<CreateVolumeData>) => {
	return queryOptions({
		queryFn: async ({ queryKey, signal }) => {
			const { data } = await createVolume({
				...options,
				...queryKey[0],
				signal,
				throwOnError: true,
			});
			return data;
		},
		queryKey: createVolumeQueryKey(options),
	});
};

/**
 * Create a new volume
 */
export const createVolumeMutation = (
	options?: Partial<Options<CreateVolumeData>>,
): UseMutationOptions<CreateVolumeResponse, DefaultError, Options<CreateVolumeData>> => {
	const mutationOptions: UseMutationOptions<CreateVolumeResponse, DefaultError, Options<CreateVolumeData>> = {
		mutationFn: async (localOptions) => {
			const { data } = await createVolume({
				...options,
				...localOptions,
				throwOnError: true,
			});
			return data;
		},
	};
	return mutationOptions;
};

export const testConnectionQueryKey = (options?: Options<TestConnectionData>) =>
	createQueryKey("testConnection", options);

/**
 * Test connection to backend
 */
export const testConnectionOptions = (options?: Options<TestConnectionData>) => {
	return queryOptions({
		queryFn: async ({ queryKey, signal }) => {
			const { data } = await testConnection({
				...options,
				...queryKey[0],
				signal,
				throwOnError: true,
			});
			return data;
		},
		queryKey: testConnectionQueryKey(options),
	});
};

/**
 * Test connection to backend
 */
export const testConnectionMutation = (
	options?: Partial<Options<TestConnectionData>>,
): UseMutationOptions<TestConnectionResponse, DefaultError, Options<TestConnectionData>> => {
	const mutationOptions: UseMutationOptions<TestConnectionResponse, DefaultError, Options<TestConnectionData>> = {
		mutationFn: async (localOptions) => {
			const { data } = await testConnection({
				...options,
				...localOptions,
				throwOnError: true,
			});
			return data;
		},
	};
	return mutationOptions;
};

/**
 * Delete a volume
 */
export const deleteVolumeMutation = (
	options?: Partial<Options<DeleteVolumeData>>,
): UseMutationOptions<DeleteVolumeResponse, DefaultError, Options<DeleteVolumeData>> => {
	const mutationOptions: UseMutationOptions<DeleteVolumeResponse, DefaultError, Options<DeleteVolumeData>> = {
		mutationFn: async (localOptions) => {
			const { data } = await deleteVolume({
				...options,
				...localOptions,
				throwOnError: true,
			});
			return data;
		},
	};
	return mutationOptions;
};

export const getVolumeQueryKey = (options: Options<GetVolumeData>) => createQueryKey("getVolume", options);

/**
 * Get a volume by name
 */
export const getVolumeOptions = (options: Options<GetVolumeData>) => {
	return queryOptions({
		queryFn: async ({ queryKey, signal }) => {
			const { data } = await getVolume({
				...options,
				...queryKey[0],
				signal,
				throwOnError: true,
			});
			return data;
		},
		queryKey: getVolumeQueryKey(options),
	});
};

/**
 * Update a volume's configuration
 */
export const updateVolumeMutation = (
	options?: Partial<Options<UpdateVolumeData>>,
): UseMutationOptions<UpdateVolumeResponse, DefaultError, Options<UpdateVolumeData>> => {
	const mutationOptions: UseMutationOptions<UpdateVolumeResponse, DefaultError, Options<UpdateVolumeData>> = {
		mutationFn: async (localOptions) => {
			const { data } = await updateVolume({
				...options,
				...localOptions,
				throwOnError: true,
			});
			return data;
		},
	};
	return mutationOptions;
};

export const getContainersUsingVolumeQueryKey = (options: Options<GetContainersUsingVolumeData>) =>
	createQueryKey("getContainersUsingVolume", options);

/**
 * Get containers using a volume by name
 */
export const getContainersUsingVolumeOptions = (options: Options<GetContainersUsingVolumeData>) => {
	return queryOptions({
		queryFn: async ({ queryKey, signal }) => {
			const { data } = await getContainersUsingVolume({
				...options,
				...queryKey[0],
				signal,
				throwOnError: true,
			});
			return data;
		},
		queryKey: getContainersUsingVolumeQueryKey(options),
	});
};

export const mountVolumeQueryKey = (options: Options<MountVolumeData>) => createQueryKey("mountVolume", options);

/**
 * Mount a volume
 */
export const mountVolumeOptions = (options: Options<MountVolumeData>) => {
	return queryOptions({
		queryFn: async ({ queryKey, signal }) => {
			const { data } = await mountVolume({
				...options,
				...queryKey[0],
				signal,
				throwOnError: true,
			});
			return data;
		},
		queryKey: mountVolumeQueryKey(options),
	});
};

/**
 * Mount a volume
 */
export const mountVolumeMutation = (
	options?: Partial<Options<MountVolumeData>>,
): UseMutationOptions<MountVolumeResponse, DefaultError, Options<MountVolumeData>> => {
	const mutationOptions: UseMutationOptions<MountVolumeResponse, DefaultError, Options<MountVolumeData>> = {
		mutationFn: async (localOptions) => {
			const { data } = await mountVolume({
				...options,
				...localOptions,
				throwOnError: true,
			});
			return data;
		},
	};
	return mutationOptions;
};

export const unmountVolumeQueryKey = (options: Options<UnmountVolumeData>) => createQueryKey("unmountVolume", options);

/**
 * Unmount a volume
 */
export const unmountVolumeOptions = (options: Options<UnmountVolumeData>) => {
	return queryOptions({
		queryFn: async ({ queryKey, signal }) => {
			const { data } = await unmountVolume({
				...options,
				...queryKey[0],
				signal,
				throwOnError: true,
			});
			return data;
		},
		queryKey: unmountVolumeQueryKey(options),
	});
};

/**
 * Unmount a volume
 */
export const unmountVolumeMutation = (
	options?: Partial<Options<UnmountVolumeData>>,
): UseMutationOptions<UnmountVolumeResponse, DefaultError, Options<UnmountVolumeData>> => {
	const mutationOptions: UseMutationOptions<UnmountVolumeResponse, DefaultError, Options<UnmountVolumeData>> = {
		mutationFn: async (localOptions) => {
			const { data } = await unmountVolume({
				...options,
				...localOptions,
				throwOnError: true,
			});
			return data;
		},
	};
	return mutationOptions;
};

export const healthCheckVolumeQueryKey = (options: Options<HealthCheckVolumeData>) =>
	createQueryKey("healthCheckVolume", options);

/**
 * Perform a health check on a volume
 */
export const healthCheckVolumeOptions = (options: Options<HealthCheckVolumeData>) => {
	return queryOptions({
		queryFn: async ({ queryKey, signal }) => {
			const { data } = await healthCheckVolume({
				...options,
				...queryKey[0],
				signal,
				throwOnError: true,
			});
			return data;
		},
		queryKey: healthCheckVolumeQueryKey(options),
	});
};

/**
 * Perform a health check on a volume
 */
export const healthCheckVolumeMutation = (
	options?: Partial<Options<HealthCheckVolumeData>>,
): UseMutationOptions<HealthCheckVolumeResponse, DefaultError, Options<HealthCheckVolumeData>> => {
	const mutationOptions: UseMutationOptions<HealthCheckVolumeResponse, DefaultError, Options<HealthCheckVolumeData>> = {
		mutationFn: async (localOptions) => {
			const { data } = await healthCheckVolume({
				...options,
				...localOptions,
				throwOnError: true,
			});
			return data;
		},
	};
	return mutationOptions;
};

export const listFilesQueryKey = (options: Options<ListFilesData>) => createQueryKey("listFiles", options);

/**
 * List files in a volume directory
 */
export const listFilesOptions = (options: Options<ListFilesData>) => {
	return queryOptions({
		queryFn: async ({ queryKey, signal }) => {
			const { data } = await listFiles({
				...options,
				...queryKey[0],
				signal,
				throwOnError: true,
			});
			return data;
		},
		queryKey: listFilesQueryKey(options),
	});
};

export const listRepositoriesQueryKey = (options?: Options<ListRepositoriesData>) =>
	createQueryKey("listRepositories", options);

/**
 * List all repositories
 */
export const listRepositoriesOptions = (options?: Options<ListRepositoriesData>) => {
	return queryOptions({
		queryFn: async ({ queryKey, signal }) => {
			const { data } = await listRepositories({
				...options,
				...queryKey[0],
				signal,
				throwOnError: true,
			});
			return data;
		},
		queryKey: listRepositoriesQueryKey(options),
	});
};

export const createRepositoryQueryKey = (options?: Options<CreateRepositoryData>) =>
	createQueryKey("createRepository", options);

/**
 * Create a new restic repository
 */
export const createRepositoryOptions = (options?: Options<CreateRepositoryData>) => {
	return queryOptions({
		queryFn: async ({ queryKey, signal }) => {
			const { data } = await createRepository({
				...options,
				...queryKey[0],
				signal,
				throwOnError: true,
			});
			return data;
		},
		queryKey: createRepositoryQueryKey(options),
	});
};

/**
 * Create a new restic repository
 */
export const createRepositoryMutation = (
	options?: Partial<Options<CreateRepositoryData>>,
): UseMutationOptions<CreateRepositoryResponse, DefaultError, Options<CreateRepositoryData>> => {
	const mutationOptions: UseMutationOptions<CreateRepositoryResponse, DefaultError, Options<CreateRepositoryData>> = {
		mutationFn: async (localOptions) => {
			const { data } = await createRepository({
				...options,
				...localOptions,
				throwOnError: true,
			});
			return data;
		},
	};
	return mutationOptions;
};

/**
 * Delete a repository
 */
export const deleteRepositoryMutation = (
	options?: Partial<Options<DeleteRepositoryData>>,
): UseMutationOptions<DeleteRepositoryResponse, DefaultError, Options<DeleteRepositoryData>> => {
	const mutationOptions: UseMutationOptions<DeleteRepositoryResponse, DefaultError, Options<DeleteRepositoryData>> = {
		mutationFn: async (localOptions) => {
			const { data } = await deleteRepository({
				...options,
				...localOptions,
				throwOnError: true,
			});
			return data;
		},
	};
	return mutationOptions;
};

export const getRepositoryQueryKey = (options: Options<GetRepositoryData>) => createQueryKey("getRepository", options);

/**
 * Get a single repository by name
 */
export const getRepositoryOptions = (options: Options<GetRepositoryData>) => {
	return queryOptions({
		queryFn: async ({ queryKey, signal }) => {
			const { data } = await getRepository({
				...options,
				...queryKey[0],
				signal,
				throwOnError: true,
			});
			return data;
		},
		queryKey: getRepositoryQueryKey(options),
	});
};

export const listSnapshotsQueryKey = (options: Options<ListSnapshotsData>) => createQueryKey("listSnapshots", options);

/**
 * List all snapshots in a repository
 */
export const listSnapshotsOptions = (options: Options<ListSnapshotsData>) => {
	return queryOptions({
		queryFn: async ({ queryKey, signal }) => {
			const { data } = await listSnapshots({
				...options,
				...queryKey[0],
				signal,
				throwOnError: true,
			});
			return data;
		},
		queryKey: listSnapshotsQueryKey(options),
	});
};

export const listBackupSchedulesQueryKey = (options?: Options<ListBackupSchedulesData>) =>
	createQueryKey("listBackupSchedules", options);

/**
 * List all backup schedules
 */
export const listBackupSchedulesOptions = (options?: Options<ListBackupSchedulesData>) => {
	return queryOptions({
		queryFn: async ({ queryKey, signal }) => {
			const { data } = await listBackupSchedules({
				...options,
				...queryKey[0],
				signal,
				throwOnError: true,
			});
			return data;
		},
		queryKey: listBackupSchedulesQueryKey(options),
	});
};

export const createBackupScheduleQueryKey = (options?: Options<CreateBackupScheduleData>) =>
	createQueryKey("createBackupSchedule", options);

/**
 * Create a new backup schedule for a volume
 */
export const createBackupScheduleOptions = (options?: Options<CreateBackupScheduleData>) => {
	return queryOptions({
		queryFn: async ({ queryKey, signal }) => {
			const { data } = await createBackupSchedule({
				...options,
				...queryKey[0],
				signal,
				throwOnError: true,
			});
			return data;
		},
		queryKey: createBackupScheduleQueryKey(options),
	});
};

/**
 * Create a new backup schedule for a volume
 */
export const createBackupScheduleMutation = (
	options?: Partial<Options<CreateBackupScheduleData>>,
): UseMutationOptions<CreateBackupScheduleResponse, DefaultError, Options<CreateBackupScheduleData>> => {
	const mutationOptions: UseMutationOptions<
		CreateBackupScheduleResponse,
		DefaultError,
		Options<CreateBackupScheduleData>
	> = {
		mutationFn: async (localOptions) => {
			const { data } = await createBackupSchedule({
				...options,
				...localOptions,
				throwOnError: true,
			});
			return data;
		},
	};
	return mutationOptions;
};

/**
 * Delete a backup schedule
 */
export const deleteBackupScheduleMutation = (
	options?: Partial<Options<DeleteBackupScheduleData>>,
): UseMutationOptions<DeleteBackupScheduleResponse, DefaultError, Options<DeleteBackupScheduleData>> => {
	const mutationOptions: UseMutationOptions<
		DeleteBackupScheduleResponse,
		DefaultError,
		Options<DeleteBackupScheduleData>
	> = {
		mutationFn: async (localOptions) => {
			const { data } = await deleteBackupSchedule({
				...options,
				...localOptions,
				throwOnError: true,
			});
			return data;
		},
	};
	return mutationOptions;
};

export const getBackupScheduleQueryKey = (options: Options<GetBackupScheduleData>) =>
	createQueryKey("getBackupSchedule", options);

/**
 * Get a backup schedule by ID
 */
export const getBackupScheduleOptions = (options: Options<GetBackupScheduleData>) => {
	return queryOptions({
		queryFn: async ({ queryKey, signal }) => {
			const { data } = await getBackupSchedule({
				...options,
				...queryKey[0],
				signal,
				throwOnError: true,
			});
			return data;
		},
		queryKey: getBackupScheduleQueryKey(options),
	});
};

/**
 * Update a backup schedule
 */
export const updateBackupScheduleMutation = (
	options?: Partial<Options<UpdateBackupScheduleData>>,
): UseMutationOptions<UpdateBackupScheduleResponse, DefaultError, Options<UpdateBackupScheduleData>> => {
	const mutationOptions: UseMutationOptions<
		UpdateBackupScheduleResponse,
		DefaultError,
		Options<UpdateBackupScheduleData>
	> = {
		mutationFn: async (localOptions) => {
			const { data } = await updateBackupSchedule({
				...options,
				...localOptions,
				throwOnError: true,
			});
			return data;
		},
	};
	return mutationOptions;
};

export const runBackupNowQueryKey = (options: Options<RunBackupNowData>) => createQueryKey("runBackupNow", options);

/**
 * Trigger a backup immediately for a schedule
 */
export const runBackupNowOptions = (options: Options<RunBackupNowData>) => {
	return queryOptions({
		queryFn: async ({ queryKey, signal }) => {
			const { data } = await runBackupNow({
				...options,
				...queryKey[0],
				signal,
				throwOnError: true,
			});
			return data;
		},
		queryKey: runBackupNowQueryKey(options),
	});
};

/**
 * Trigger a backup immediately for a schedule
 */
export const runBackupNowMutation = (
	options?: Partial<Options<RunBackupNowData>>,
): UseMutationOptions<RunBackupNowResponse, DefaultError, Options<RunBackupNowData>> => {
	const mutationOptions: UseMutationOptions<RunBackupNowResponse, DefaultError, Options<RunBackupNowData>> = {
		mutationFn: async (localOptions) => {
			const { data } = await runBackupNow({
				...options,
				...localOptions,
				throwOnError: true,
			});
			return data;
		},
	};
	return mutationOptions;
};
